<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Warehouse Inventory Optimization</title>
  <link rel="stylesheet" href="styles.css" />
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      background: #f1f3f6;
      margin: 0;
      padding: 0;
    }

    header {
      background-color: #2874f0;
      padding: 16px;
      color: white;
      font-size: 20px;
      font-weight: bold;
      text-align: center;
    }

    .container {
      max-width: 960px;
      margin: 40px auto;
      background: white;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      padding: 32px;
      border-radius: 8px;
    }

    h1 {
      color: #212121;
      margin-bottom: 20px;
    }

    h2 {
      color: #2874f0;
      margin-top: 32px;
    }

    p {
      color: #424242;
      line-height: 1.6;
    }

    ul {
      color: #424242;
      line-height: 1.6;
    }

    pre {
      background-color: #f7f7f7;
      padding: 16px;
      overflow-x: auto;
      border-left: 5px solid #2874f0;
      font-size: 14px;
    }

    a.back {
      display: inline-block;
      margin-top: 30px;
      color: #2874f0;
      text-decoration: none;
      font-weight: bold;
    }

    a.back:hover {
      text-decoration: underline;
    }
  </style>
</head>

<body>
  <header>Flipkart Business Case</header>
  <div class="container">
    <h1>Warehouse Inventory Reorganization</h1>

    <h2>üì¶ The Story</h2>
    <p>Imagine a Flipkart warehouse buzzing during a Big Billion Days sale. Staff are rushing to fetch chargers, phones, and books ‚Äî but some popular items are stacked in the farthest corners. What if we could redesign the layout based on real-time product demand?</p>

    <h2>üìå Problem Statement</h2>
    <p>To minimize pick times and improve operational efficiency, frequently ordered items must be positioned closer to the dispatch zone. The goal is to adaptively reorganize the layout using data-driven decisions.</p>

    <h2>üß† Algorithms & Concepts</h2>
    <ul>
      <li><strong>Greedy Sorting:</strong> Sort SKUs (stock-keeping units) based on order frequency. Fast and effective for static reorganization.</li>
      <li><strong>Hash Map:</strong> Efficient data structure to maintain SKU access counts.</li>
      <li><strong>Heap / Priority Queue:</strong> Keeps top-K hottest items in constant time ‚Äî useful for dynamic layouts.</li>
    </ul>

    <h2>üìö Explanation of Concepts</h2>
    <ul>
      <li><strong>Greedy Algorithm:</strong> At each step, make the locally optimal choice ‚Äî here, place most accessed items in the front.</li>
      <li><strong>Heap / Priority Queue:</strong> A binary tree-based structure where highest-frequency items bubble to the top. Used when frequent updates are needed.</li>
      <li><strong>Hash Map:</strong> Associates each item (SKU) with how many times it's accessed, with average O(1) access and update time.</li>
    </ul>

    <h2>üìä Time & Space Complexity</h2>
    <ul>
      <li>Greedy Sort: O(N log N)</li>
      <li>Hash Map Frequency Count: O(N)</li>
      <li>Top-K with Heap: O(N log K)</li>
    </ul>

    <h2>üí• Real-World Impact</h2>
    <ul>
      <li>üî• 20-30% faster order picking during sales.</li>
      <li>üí∞ Reduced warehouse labor costs.</li>
      <li>üöö Faster delivery -> Higher customer satisfaction.</li>
    </ul>

    <h2>üíª Sample Code (Greedy Sorting in C++)</h2>
    <pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;algorithm&gt;
using namespace std;

int main() {
    unordered_map&lt;string, int&gt; accessFrequency = {
        {"Phone", 120}, {"Charger", 300}, {"Laptop", 80},
        {"Shoes", 250}, {"T-shirt", 180}, {"Book", 220}
    };

    vector&lt;pair&lt;string, int&gt;&gt; items(accessFrequency.begin(), accessFrequency.end());

    sort(items.begin(), items.end(), [](auto &a, auto &b) {
        return a.second &gt; b.second;
    });

    cout &lt;&lt; "\nOptimal Warehouse Placement Order:\n";
    for (auto &item : items) {
        cout &lt;&lt; item.first &lt;&lt; " (" &lt;&lt; item.second &lt;&lt; ")\n";
    }
    return 0;
}</code></pre>

    <h2>üñºÔ∏è Visual Suggestions</h2>
    <ul>
      <li>Heatmap image of warehouse showing item popularity zones.</li>
      <li>Bar chart: SKU vs Access Count.</li>
      <li>Before vs After layout sketch: Popular items moving closer to dispatch.</li>
    </ul>

    <a href="index.html" class="back">‚Üê Back to Business Cases</a>
  </div>
</body>

</html>
